##### 粘包(sticky packet)、半包(half packet)
是TCP这种面向数据流的传输层机制导致的。在TCP中传输的是源源不断的字节流，应用层定义的数据与数据之间没有边界，那么在收发数据包时，就有可能一次性读到多个数据体，也有可能一个数据体被分割到多个数据包中。具体原因如下：
- socket write buffer剩余空间不足，只能写入部分数据体，会造成发送端进行拆包（但是不一定就造成服务端的半包现象）
- socket write buffer中的字节流包含了多个数据体的内容，会造成发送端粘包现象（但是不一定就造成服务端的粘包现象）
- 发送端数据受MTU的影响，会进行拆包处理，会造成发送端拆包现象（但是不一定就造成服务端的半包现象）
- Nagle算法会将小数据包进行合并，会造成发送端粘包现象
- 接收端处理数据的延迟导致接收缓冲区数据积压，会造成接收端粘包现象
- 接收端接收缓冲区满了，最后一个数据包，可能发生半包现象
- 接收端每次read的字节数，和数据包的字节数差异，会造成服务端半包现象

##### 解决办法(Solutions):
- 短连接：每次发送完数据之后，立刻断开连接（缺点：socket频繁连接会存在明显延迟；且资源占用多，客户端TIMEWAIT状态的连接在2 MSL内都是占用系统资源的；数据之间没有上下文信息了）。
- 定长报文：将数据体进行定长编码，不足时使用空白字符代替（缺点：不足定长规定时，会造成浪费现象）
- 分割符：数据体与数据体之间使用分割符进行区分（缺点：需要考虑数据体本身包含分割符的情况，需要对冲突的地方做转义处理；也可以将数据进行base64编码，分割符选择编码协议之外的字符）
- 长度编码：每个数据包头部都记录该数据体的长度，接收端先解析头部，然后读取指定长度的数据即可（缺点：长度信息所需字节数需要兼容大小报文，可以采用变长编码的方式）

##### 其他：
TCP提供的保证：
- 数据流中的字节序和发送者的数据体保持一致，不会发生被其他数据体插入或者本身顺序错乱的情况（比如先后发送两个数据体："hello"和"world"，tcp数据流中不会出现"helworldlo", 或者"olleh"的情况）

##### 参考资料：
- https://blog.spacepatroldelta.com/a?ID=00350-bd73d91c-8f52-4674-a385-ee86a58bb0ce
- https://juejin.cn/book/6844733788681928712/section/6844733788841328648
- https://blog.csdn.net/qq_45656248/article/details/123980073